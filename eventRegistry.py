
"""
Events: Can prevent travel to/from locations, create/delete/change items, print specific text.
Operate based on triggers, which can be an attribute or action being applied to a specific item or item-named-object.
Can be generated by a repeating trigger, can start from runtime or can start 'paused' and waiting a specific trigger.

Current examples:
Pick up the map, a key falls out. [if map is in inventory, runs an event which makes the key not-hidden and reprints the location description]
Unlock the door, player can leave the graveyard. [From start, and event is running halts travel outside of the graveyard. When the padlock is unlocked using the defined iron key, the event ends, releasing the travel restriction and printing a message.]
Pick up moss, keep it dry for three days, it becomes dry moss. [Not fully implemented, but timedTriggers track the passage of time and emit once the required duration has been met.]
"""

import uuid

from itemRegistry import itemInstance
from logger import logging_fn
from misc_utilities import assign_colour, has_and_true
from testing_coloured_descriptions import init_loc_descriptions
import config

event_states = {
    "past": 0,
    "current": 1,
    "future": 2
}

event_state_by_int = {
    0: "past/completed",
    1: "current/ongoing",
    2: "future/not started"
}

def load_json():
    import json, config
    with open(config.event_data, 'r') as loc_data_file:
        event_dict = json.load(loc_data_file)
    return event_dict

event_dict = load_json()

#acts = ["is_broken"]
acts = {"is_broken": {"moved_children": {"[[children]] <fall> from the broken [[noun]]."}},
        "is_burned": {"moved_children": {"[[children]] <fall> from the burned [[noun]]"}}}

trigger_acts = { # the k/v a verb action has to send in order to meet the trigger requirement.
    "item_broken": {"is_broken": True},
    "item_burned": {"is_burned": True},
    "item_unlocked": {"is_locked": False},
    "item_opened": {"is_open": True}
}
## very similar to the one above but slightly different and worth it to keep them separate. Later events may make them diverge further, at which point I'll make it clearer.
# the action name from verb_actions that needs to be in trig.triggers.

trigger_actions = ["item_in_inv", "item_broken", "item_burned", "item_unlocked", "item_not_in_inv"]

requires_end_trigger_loc = ["none yet", "just a placeholder", "for something that needs you to be in a specific place."]

event_effects = ["held_items", "locked_items", "hidden_items", "limit_travel", "init_items", "remove_items"]

effect_attrs = {
    "held_items": {
        "on_event_start": {"can_pick_up": False},
        "on_event_end": {"can_pick_up": True}},
    "locked_items": {
        "on_event_start": {"is_open": False, "is_locked": True},
        "on_event_end": {"is_open": True, "is_locked": False}},
    "hidden_items": {
        "on_event_start": {"is_hidden": True, "can_pick_up": False},
        "on_event_end": {"is_hidden": False, "can_pick_up": True}}
}


class eventInstance:

    def __init__(self, name, attr):
        self.name = name
        self.id = str(uuid.uuid4())
        self.short_id = self.id.split("-")[-1]
        if attr.get("starts_current"):
            self.state:int = 1
            #print(f"Event {self.name} starts current: {self.state}")
        else:
            self.state:int = 2
        self.triggers = set() #all triggers, delineate start/end after this point.
        self.start_triggers = set() # just to make sure these are here so other things can be more solid.
        self.end_triggers = set()
        self.items = set()
        self.event_keys = set()
        self.generate_on_start = set() # set of item names to generate on start, for events that have items 'appear' when they run (eg scroll has key, key 'falls out of scroll' at current loc.) Except not that example, becaues that's now an immediate event. Instead, for something like 'a gem is created, then the rest of the quest carries on'. So, rare but potentially will exist one day.
        self.effects_on_start = {}

        self.item_name_to_inst = {} # to track 'iron key' to instance, to make sure instances are tracked through events. Note: Only works as intended if only one instance per name. If an event has multiple instances of one itemname, will need an alt route.
        self.msgs = attr.get("messages") # what prints when the event starts/ends/on certain cues
        self.limits_travel = False
        #print(f"\n{name} ATTR@ ::: {attr} \n\n")
        #print(f"STATE: {self.state}")
        self.held_items = (attr.get("held_items") if attr.get("held_items") else set())
        self.hidden_items = (attr.get("hidden_items") if attr.get("hidden_items") else set()) # These were dicts with item: item_loc. I can't see where/why I'm using the location though, that should be done with in item inst identification. Changing (back?) to sets.
        self.locked_items = (attr.get("locked_items") if attr.get("locked_items") else set())
        #print(f'attr.get("hidden_items"): {attr.get("hidden_items")}')
        #print(f'self.hidden_items: {self.hidden_items}')
        self.remove_items = set() # for short-term storage of item instances to be removed by events.
        self.start_trigger_location = None
        self.end_trigger_location = None

        self.condition_items = set() ## for keeping items that are part of timed triggers.

        self.no_item_restriction = {} # Keeping this on the event. [Item_name] = [instance]
        self.constraint_tracking = {} # [constraint_type (eg 'days')] = int(starts at 0)} #each instance triggers its own event, so one instance per event. At least for now, so I can track failures/successes by event state, instead of managing sub-event failures/successes. # might get rid of this and just use timed_triggers below instead.
        self.timed_triggers = set()

        for item in attr:
            setattr(self, item, attr[item])

        if attr.get("on_event"):
        #if attr.get("immediate_action") and attr["immediate_action"].get("item_trigger") and attr["immediate_action"]["item_trigger"].get("on_event"):
            self.on_event = attr["on_event"] # Surely this is unnecessary, should be added by the item in attr, right?

        if attr.get("limit_travel"):
            self.limits_travel = True

    def __repr__(self):

        event = f"\033[30;44m<eventInst {self.name} ..{self.short_id}>\033[0m"
        return event
        #return f"<eventInst {self.name} ..{self.short_id}>"#, event state: {self.state}>"#, all attributes: {self.attr})>"


class timedTrigger:

    trigger_coloured = "[\033[42mtimedTrigger\033[0m]]"

    def __init__(self, trigger_dict, event:eventInstance):

        self.id = str(uuid.uuid4())
        self.event = event#trigger_dict["event"]
        self.state = event.state
        self.is_item_trigger = False
        self.item_inst = None
        self.triggers = set([str]) #item_broken, 'item_in_inv', etc.

        """
        trigger_dict = {
            "event": event,
            "trigger_model": "item_trigger",
            "trigger_type": trigger,
            "trigger_item": trigger_item,
            "trigger_item_loc": trigger_loc,
            "trigger_actions": trigger_actions,
            "item_flags_on_start": item_flags_on_start,
            "item_flags_on_end": item_flags_on_end
            }
            """

        self.start_trigger = False
        self.end_trigger = True
        event.end_triggers.add(self)

        timed_dict = trigger_dict["timed_trigger"]
        self.time_unit = timed_dict["time_unit"]  # "days",
        self.full_duration = timed_dict["full_duration"]  # 3,

        event.constraint_tracking[self.time_unit] = {"full_duration": self.full_duration, "current_duration": 0}

        self.persistent_condition = timed_dict["persistent_condition"]  # true,

        #if self.persistent_condition:
            #print(f"[Event must have condition maintained until completion of {self.full_duration} {self.time_unit}s.]")
        self.required_condition = timed_dict["required_condition"]

        self.condition_item_is_start_trigger = timed_dict["condition_item_is_start_trigger"]

        for condition, value in self.required_condition.items():
            #print(f"condition: {condition}, value: {value}")
            self.triggers.add(condition)
            if condition not in trigger_actions:
                print(f"Required_condition not known: {condition} // [value ({value}])")
                continue

            if event.is_generated_event or not event.item_name_to_inst.get(value):
                if self.required_condition.get(condition):
                    #print(f"self.required_condition[condition]: {self.required_condition[condition]}")
                    condition_item = self.required_condition[condition]
                    #print(f"TRIGGER DICT: {trigger_dict} ::: entry: {trigger_dict["trigger_item"]}")
                    if trigger_dict.get("trigger_item") and isinstance(trigger_dict["trigger_item"], itemInstance):
                        #print(f"TRIGGER ITEM: {trigger_dict["trigger_item"]}")
                        self.is_item_trigger = True
                        if trigger_dict["trigger_item"].name == condition_item:
                                #print("The instance sent with the trigger data will be used.")
                                self.item_inst = trigger_dict["trigger_item"]
                        #if trig_data["trigger_item"].name == self.required_condition["item_in_inv"]:
                                setattr(self, self.required_condition[condition], trigger_dict["trigger_item"])
                                #self.required_condition["item_in_inv"] = trig_data["trigger_item"]

                        else:
                            print("Needs an instance here but apparently couldn't find one. This is real bad, something's wrong upstream.")
                            exit()
                    elif trigger_dict.get("timed_trigger"):
                        #print(f"Trigger dict[timed_trigger]: {trigger_dict["timed_trigger"]}")
                        for entry, v in self.required_condition[condition].items():
                            #print(f"V: {v}")
                            if event.item_name_to_inst.get(v):
                                self.item_inst = v
                                setattr(self, self.required_condition[condition], v)
                        #if trig_data["trigger_item"].name == self.required_condition["item_in_inv"]:
                                #setattr(self, self.required_condition[condition], trig_data["trigger_item"])
                else:
                    print(f"No self.required_condition[condition]: {self.required_condition[condition]}")

            elif event.item_name_to_inst.get(value):
                print("THIS SHOUILD NOT BE HERE IF THE EVENT IS AUTOGENNED. Same for regular triggers.")
                self.item_inst = event.item_name_to_inst[value]
                self.required_condition[condition] = self.item_inst
                print(f"required condition[condition]: {self.required_condition[condition]}")

            event.condition_items.add(self.item_inst)

            event.constraint_tracking[self.time_unit].update({"required_condition": condition, "condition_item": self.item_inst})

            event.items.add(self.item_inst)

            """
        So event.constraint_tracking should be:
            event.constraint_tracking: {
                "day: {
                    "full_duration": self.full_duration,
                    "current_duration": 0,
                    "condition": "item_in_inv",
                    "condition_item": <moss_instance>}
                }

        If the duration is completed, the event succeeds.
        If an end trigger is hit, it succeeds/fails depending on the state in the trigger (so possibly, an event might have an end trigger that makes it succeed early (you find a warm fire and put the moss near it, it dries in one day instead of 3, etc).).

        """

    def __repr__(self):
        item = f'Trigger item: {self.item_inst.name}/{self.item_inst.short_id}'
        if config.coloured_repr and hasattr(self.item_inst, "code"):
            coloured_text = f"\033[{self.item_inst.code + 10}m{item}\033[0m"
        else:
            coloured_text = item
        return f"<{timedTrigger.trigger_coloured} {self.id} for event {self.event.name}, event state: {event_state_by_int[self.state]}, {((coloured_text if isinstance(self.item_inst, itemInstance) else f'Trigger item: {self.item_inst}') if self.is_item_trigger else None)}>"

class Trigger:

    trigger_coloured = "[\033[41mTrigger\033[0m]]"

    def __init__(self, trigger_dict, event:eventInstance):

        self.id = str(uuid.uuid4())
        self.event = event
        self.state = event.state

        self.triggers = set() #item_broken, 'item_in_inv', etc.
        self.exceptions = set()
        """
        trigger_dict = {
            "event": event,
            "trigger_model": "item_trigger",
            "trigger_type": trigger,
            "trigger_item": trigger_item,
            "trigger_item_loc": trigger_loc,
            "trigger_actions": trigger_actions,
            "item_flags_on_start": item_flags_on_start,
            "item_flags_on_end": item_flags_on_end
            "trigger_exceptions": trigger_exceptions
            }
            """
        if trigger_dict["trigger_type"] == "end_trigger":
            self.start_trigger = False
            self.end_trigger = True
            event.end_triggers.add(self)
        else:
            self.start_trigger = True
            self.end_trigger = False
            event.start_triggers.add(self)

        if trigger_dict["trigger_model"] == "item_trigger":
            self.is_item_trigger = True
            if self.is_item_trigger:
                if isinstance(trigger_dict["trigger_item"], itemInstance):
                    self.item_inst = trigger_dict["trigger_item"]
                else:
                    if (isinstance(trigger_dict["trigger_item"], list|set|tuple) and len(len(trigger_dict["trigger_item"]) == 1)):
                        self.item_inst = trigger_dict["trigger_item"][0]

                event.items.add(self.item_inst)
                self.item_inst_loc = trigger_dict["trigger_item_loc"]
                if self.end_trigger:
                    event.end_trigger_location = self.item_inst_loc
                self.item_flags_on_start = trigger_dict["item_flags_on_start"]
                self.item_flags_on_end = trigger_dict["item_flags_on_end"]

                if isinstance(self.item_inst, itemInstance):
                    setattr(self.item_inst, "event", event)
                    if self.state == 1:
                        if self.item_flags_on_start:
                            for flag in self.item_flags_on_start:
                                setattr(self.item_inst, flag, self.item_flags_on_start[flag])

        else:
            self.is_item_trigger = False

        if isinstance(trigger_dict["trigger_actions"], str):
            self.triggers.add(trigger_dict["trigger_actions"])
        else:
            for action in trigger_dict["trigger_actions"]:
                self.triggers.add(action)
        if self.triggers:
            if trigger_dict.get("trigger_exceptions"):
                for exception in trigger_dict["trigger_exceptions"]:
                    self.exceptions.add(exception)
            else:
                self.exceptions = set()
        event.triggers.add(self)

    def __repr__(self):
        return f"<{Trigger.trigger_coloured} {self.id} for event {self.event.name}, event state: {event_state_by_int[self.state]}, {((f'Trigger item: {self.item_inst.name}/{self.item_inst.short_id}' if isinstance(self.item_inst, itemInstance) else f'Trigger item: {self.item_inst}') if self.is_item_trigger else None)}>"

class eventRegistry:

    def __init__(self):

        self.events = set()
        self.by_id = {}
        self.by_name = {}
        self.by_state = {}
        self.trigger_items = {}
        self.travel_is_limited = False
        self.triggers = set([Trigger])
        self.item_names = dict()

        self.start_triggers = dict() #self.start_trigger_is_item

        self.no_item_restriction = {}

        self.generate_events_from_itemname = {}

        self.timed_triggers = set()
        self.condition_items = set()

        for state in event_states.values():
            self.by_state[state] = set()

        #self.remove_event_on_failure = set() #add instances with remove_event_on_failure: true here, delete them and their triggers (and item.event assignement) when failed. Mostly things like the moss, which will stop/start and have no impact. Not standard, usually I'll keep them around and just not marked as event_keys. # Just storing it on the event instead, makes more sense.

    def add_event(self, event_name, event_attr):

        event = eventInstance(event_name, event_attr)
        self.events.add(event)
        self.by_id[event.id] = event
        if not self.by_name.get(event.name):
            self.by_name[event.name] = set()
        self.by_name[event.name].add(event)

        if event.limits_travel:
            self.travel_is_limited = True

        if hasattr(event, "starts_current") and event.starts_current:
            self.by_state[1].add(event)
            event.state = 1 # (current event)

        else:
            #print(f"Event not starts_current: {event}")
            self.by_state[2].add(event)
            event.state = 2 # (future event)

        if self.timed_triggers:
            events.timed_events.add(self)

        return event, event_attr

    def clean_messages(self, event, noun=None, msg = None):
        logging_fn()
        if msg == None:
            messages = event.msgs
            #print(f"MESSAGES: {messages}")
            #print(f"event: {event}, noun: {noun}")
            for part, message in messages.items():
                if "[[]]" in message:
                    new_message = message.replace("[[]]", noun.name)
                    #print(f"CLEANED MESSAGE: {message}")
                    event.msgs[part] = new_message
                else:
                    event.msgs[part] = msg
        else:
            if "[[]]" in msg:
                new_message = msg.replace("[[]]", noun.name)
                return new_message
            else:
                return msg

    def get_all_item_instances(self, event:eventInstance, event_entry, noun=None):
        from itemRegistry import registry
        event.item_name_to_inst = {}

        if not hasattr(event, "item_name_to_loc"):
            print(f"No item_name_to_loc dict for {event}\n")

        if noun and noun.name not in event.item_names:
            event.item_names.add(noun.name)

        for item in event.item_names:
            if event.item_name_to_inst.get(item) and not noun:
                continue
            instance = None
            if not noun:
                if event.item_name_to_loc.get(item):
                    item_loc = event.item_name_to_loc[item]
                    from interactions.item_interactions import find_local_item_by_name

                    loc_items = registry.get_item_by_location(item_loc) #don't think it will cause issues to include inv. Undo it later if so.
                    for loc_item in loc_items: # we loop through them all but only add one. Why?
                        if loc_item.name in event.item_names: # instead of just the given item, add any matches found at once.#== item:
                            #print(f"Found instance for {loc_item.name} in {item_loc}: {loc_item}")
                            instance = loc_item
                            event.item_name_to_inst[loc_item.name] = instance
                            event.items.add(instance) # vv
                            instance.event = event ## ^^ These were not added previously. I'm pretty sure they should be.

            if noun:
                instance = noun
                event.item_name_to_inst[noun.name] = instance
                event.items.add(instance)
                instance.event = event

            if not instance:
                if event_entry:
                    print(f"EVENT ENTRY: \n{event_entry}, no instance found")
                #loc_items = registry.get_item_by_location(item_loc) # this will error if no item was found. Why even try to get it at this point?
                print(f"No instance found by location for {item}")

        missing = list(i for i in event.item_names if i not in event.item_name_to_inst)
        if missing:
            if event.state != 1:
                for item in missing:
                    event.generate_on_start.add(item)
            print(f"Missing instances: [[{missing}]]")

    def get_event_by_noun(self, event_name, noun_inst):

        if event_name:
            event = self.event_by_name(event_name)
            #for event in self.event_by_name(event_name):
            if noun_inst in event.items:
                noun_inst.event = event
                return event
        return


    def get_event_name_by_attr_trigger(self, attr_trigger):

        def get_parts_from_tuple(attr_trigger):
            if isinstance(attr_trigger, tuple):
                for tup in attr_trigger:
                    #print(f"tup type: {type(tup)}")
                    if isinstance(tup, tuple):
                        get_parts_from_tuple(tup)
                        return tup
                    else:
                        #print(f"tup: {tup}, type: {type(tup)}")
                        #print(f"attr_trigger: {attr_trigger}")
                        return attr_trigger


        attr_trigger = get_parts_from_tuple(attr_trigger)
        if not attr_trigger:
            return None
        #print(f"attr_trigger after tuple: {attr_trigger}, type: {type(attr_trigger)}")
        trigger, val = attr_trigger
        for event in registrar.start_trigger_is_attr:
            #print(f"EVENT: {event}")
            #print(f"EVENT vars: {vars(event)}")
            #print(f"Event.attr_triggers: {event.attr_triggers}")
            #print(f"attr_trigger: {attr_trigger}")
            for item in event.attr_triggers:
                trig = trigger_acts.get(item)
                if not trig:
                    #print("No trig.")
                    return None
                #print(f"TRIG: {trig}, type: {type(trig)}")
                if trig.get(trigger):
                    if trig[trigger] == val:
                        #print(f"event.name: {event.name}")
                        return event.name


    def clean_altered_state_def(self, item_name, item_entry, state_change):
        """
    "state_change" == "already_broken"/"already_burned", etc.
        Removes attrs etc from the existing item entry and creates a new modified entry for the item.
        To remove:
                for k, item_name in event.init_items[each].items():
                    if k == "item_name":
                        inst = None
                        if item_name == "on_break_item" and noun:
        Basically, strip out all the parts that make it possible for a thing to be broken. Also those things should be /far/ better defined than they are. Jeez.
        """
        #print(f"clean atered state def \n item name: {item_name} / item entry:\n{item_entry}")
        """
Dict of broken glass as it arrives:
{'alt_names': ['broken glass shards', 'glass shards', 'shards of glass', 'shard of glass', 'shard', 'shards'], 'can_pick_up': True, 'descriptions': {'is_singular': 'a shard of broken glass.', 'is_plural':
'a scattering of broken glass.'}, 'has_multiple_instances': 3, 'single_identifier': 'shard', 'plural_identifier': 'shards', 'item_size': 'small_flat_things', 'item_type': ['can_pick_up', 'is_cluster', 'standard'], 'nicenames': {'is_singular': 'a glass shard', 'is_plural': 'a few shards of glass'}, 'slice_attack': 10, 'slice_defence': 4, 'smash_attack': 2, 'smash_defence': 2, 'material_type': 'generic', 'on_break': 'broken [[item_name]]'}

So I just need to change {material_type}: {on_break: broken_name} to "already_broken": {None:None}. Most straightforward way.

'material_type': 'generic', 'on_break': 'broken [[item_name]]'}
        """
        #from itemRegistry import material_type
        if state_change == "is_burned":
            state_change = "already_burned"
            action = "on_burn"
        if state_change == "is_broken":
            state_change = "already_broken"
            action = "on_break"
        #print(f"state change: {state_change}")
        item_entry["material_type"] = state_change
        #if not item_entry["nicenames"]:
        if "is_cluster" in item_entry["item_type"] and not item_entry.get("is_broken"):
            item_entry["nicenames"] = {"generic": f"some {item_name}"}
            item_entry[action] = None
        return item_entry


    def manage_constraint_tracking(event):
        """
        Call this from the day/time management (set_up_game, probably) to check if any time-based events have completed.
        """
        if event.timed_triggers:
            for trigger in event.timed_triggers:
               constraint_current = trigger.constraint_tracking
               event_constraint = trigger.time_constraint
               for constraint_option in ("days", "timeblocks"):
                   if event_constraint.get(constraint_option):
                       if constraint_current[constraint_option] == event_constraint[constraint_option]:
                           print("Event completed, let something happen here.")
                           print("Then once it happens, run end_event.")
                           return True

        return False

    def get_event_triggers(self, event, event_name = None, trigger_check = None):
        logging_fn()

        from itemRegistry import registry

        if event:
            if isinstance(event, eventInstance):
                if not event_name:
                    event_name = event.name
            elif isinstance(event, str):
                event_name = event
                event = self.event_by_name(str)
                if not event:
                    print(f"No event by the name {event_name}")
                    exit()
                if isinstance(event, list):
                    if len(event) > 1:
                        print(f"There is more than one event named {event_name}. Arbitrarily picking the first, but this may be wrong.")
                    event = event[0]

        if not event and event_name:
            if isinstance(event_name, eventInstance):
                event = event_name
                event_name = event.name

        #
        #if event.is_generated_event:
        #    print(f"{event} is a generated event, no pre-defined instances here.")

        for trigger in ("start_trigger", "end_trigger", "immediate_action"):
            trigger_dict = {}
            trig_data = {}
            if hasattr(event, trigger) and getattr(event, trigger):
                for entry in getattr(event, trigger):
                    trig_data[entry] = getattr(event, trigger)[entry]

                trigger_exceptions = set()

                if trig_data.get("item_trigger"):

                    trigger_item = trig_data["item_trigger"]["trigger_item"]
                    if event.is_generated_event:
                        if trigger_check:
                            trigger_item = trigger_check
                            event.items.add(trigger_item)
                            event.item_names.add(trigger_item.name)
                        else:
                            print(f"{event.name} is a generated event, but no trigger item was provided.")
                    else:
                        if event.item_name_to_inst.get(trigger_item):
                            trigger_item = event.item_name_to_inst[trigger_item]
                        else:
                            trigger_items = registry.instances_by_name(trigger_item) # TODO make this more selective.
                            for item in trigger_items:
                                if not hasattr(item, "event"):
                                    trigger_item = item
                                    break
                            # Assumes that an item of that name will be correct by default. Not ideal. Should probably check it has the event tag, but here we're ruling those /out/ instead of prioritising them. TODO: Will work on this later.

                    trigger_actions = trig_data["item_trigger"]["triggered_by"]
                    trigger_exceptions = trig_data["item_trigger"].get("exceptions")

                    item_flags_on_start = trig_data["item_trigger"].get("on_event_start")
                    item_flags_on_end = trig_data["item_trigger"].get("on_event_end")

                elif event.is_generated_event:
                    if trigger_check:
                        trigger_item = trigger_check
                        event.items.add(trigger_item)
                        event.item_names.add(trigger_item.name)
                        #print("Is generated events, trigger actions: ")
                        trigger_actions = trig_data["attribute_trigger"]["triggered_by"]
                        item_flags_on_start = item_flags_on_end = None

                trigger_item_loc = (trigger_item.location if isinstance(trigger_item, itemInstance) else None)
                if not trigger_item_loc and trig_data.get("item_trigger"):
                    if trig_data["item_trigger"].get("trigger_item_location"):
                        trigger_item_loc = trig_data["item_trigger"]["trigger_item_location"]

                trigger_dict.update({
                    "event": event,
                    "end_type": (trig_data["item_trigger"].get("end_type") if trig_data.get("item_trigger") else None),
                    "trigger_model": "item_trigger",
                    "trigger_type": trigger,
                    "trigger_item": trigger_item,
                    "trigger_item_loc": trigger_item_loc,
                    "trigger_actions": trigger_actions,
                    "item_flags_on_start": item_flags_on_start,
                    "item_flags_on_end": item_flags_on_end,
                    "trigger_exceptions": trigger_exceptions
                    })

                if trig_data.get("item_trigger"):
                    event.event_keys.add(trigger_item)
                    event.triggers.add(Trigger(trigger_dict, event))


                if trig_data.get("attribute_trigger"): # this is currently identical. Not sure if it'll need to change later or not.
                    if event.is_generated_event:
                        if trigger_check:
                            trigger_item = trigger_check
                            event.items.add(trigger_item)
                            event.item_names.add(trigger_item.name)
                            #print(f"TRIGGER ITEM FROM TRIGGER CHECK: {trigger_item}, vars: {vars(trigger_item)}")
                    event.event_keys.add(trigger_item)
                    event.triggers.add(Trigger(trigger_dict, event))


                if trig_data.get("timed_trigger"):
                    #print("trig data timed trigger")
                    if event.is_generated_event:
                        #print("event is generated event")
                        if trigger_check:
                            #print(f"is trigger check: {trigger_check}")
                            trigger_item = trigger_check
                            trigger_dict["trigger_item"] = trigger_item
                            #print(f'trigger_dict["trigger_item"] : {trigger_dict["trigger_item"] }')
                        else:
                            print("no trigger check")
                    #else:
                        #print(f"event {event} is not is_generated_event")
                    #print(f"Trig data timed trigger: {trig_data["timed_trigger"]}")
                    trigger_dict["trigger_model"] = "timed_trigger"
                    trigger_dict["timed_trigger"] = trig_data["timed_trigger"]
                    event.event_keys.add(trigger_item)
                    event.triggers.add(timedTrigger(trigger_dict, event))
                    #print(f"EVENT TRIGGERS: {event.triggers}")

        effects_dict = {}
        for effect in event_effects:
            if hasattr(event, effect) and getattr(event, effect):
                if effect_attrs.get(effect):
                    effects_dict[effect] = {}

                    for item in getattr(event, effect):
                        if isinstance(item, itemInstance):
                            event_item = item
                        else:
                            event_item = event.item_name_to_inst.get(item)

                        if not event_item:
                            if item in event.generate_on_start:
                                if not event.effects_on_start.get(effect):
                                    event.effects_on_start[effect] = list()
                                event.effects_on_start[effect].append(item)
                                continue
                            else:
                                print(f"Event generate_on_start: {event.generate_on_start}")
                                print(f"No event item found for {event} with name {item}, exiting.")
                                exit()

                        effects_dict[effect][item] = event_item

                        if effect_attrs[effect].get("on_event_start"):
                            #print(f"effect_attrs[effect]['on_event_start']: {effect_attrs[effect]['on_event_start']}")
                            for k, v in effect_attrs[effect]["on_event_start"].items():
                                setattr(event_item, k, v)

                        if not event_item in event.items:
                            event.items.add(event_item)

                        setattr(event_item, "event", event)


        if effects_dict:
            for effect in effects_dict:
                for item in effects_dict[effect]:
                    if isinstance(item, str):
                        #print(f"Before removing the str and adding the instance: \n{getattr(event, effect)}")
                        getattr(event, effect).remove(item)
                        getattr(event, effect).add(effects_dict[effect][item])
                        #print(f"Removed {item} from event.{effect}, added {effects_dict[effect][item]}:\n{getattr(event, effect)}")

        return event

    def get_event_item_names(self, event):
        logging_fn()

        #print(f"Get event item names: EVENT:: {event}, type: {type(event)}")

        def get_items_inner(event):

            for item in event.items:
                #print(f"ITEM IN EVENT ITEMS: {item}")
                if isinstance(item, itemInstance):
                    events.item_names[item.name] = item
                    setattr(item, "event", event) # TODO: Doing this way too often, need to find the single choke point they all pass through no matter where they're added from.
                    if hasattr(event, "event_keys") and item in event.event_keys:
                        item.is_event_key = True
                else:
                    print(f"This item does not have an instance: {item} (in event {event.name})")

        if isinstance(event, str):
            event_options = self.event_by_name(event)
            #for event in event_options:
            get_items_inner(event_options)
            return

        get_items_inner(event)

    def event_by_state(self, state)-> set:
        if not isinstance(state, int):
            if (isinstance(state, str) and len(state)==1):
                state = int(state)
            elif state in event_states:
                state = event_states[state]

        return self.by_state.get(state)


    def event_by_id(self, event_id)-> eventInstance:

        if not isinstance(event_id, str):
            event_id = str(event_id)

        instance = self.by_id(event_id)
        if instance:
            return instance

    def event_by_name(self, event_name:str)-> eventInstance: # actually |list but the typehints of it thinking it starts as eventInstance is more useful.

        if isinstance(event_name, str):
            instance = self.by_name.get(event_name)

            if instance:
                if isinstance(instance, eventInstance):
                    return instance
                if isinstance(instance, set|list|tuple):
                    if len(instance) == 1:
                        if isinstance(instance, set|tuple):
                            return list(instance)[0]
                        return instance[0]
                    else:
                        print(f"Multiple instances in {instance} for name {event_name}. Haven't dealt with this yet. Returning first arbitrarily.") # have only had this happen when running a memory test. Not sure why it did, but it doesn't happen in regular use.
                        return list(instance)[0]

    def play_held_msg(self, event=None, print_txt=False):
        logging_fn()

        if self.travel_is_limited:
            if event == None:
                holder = self.held_at.get("held_by") # currently only works if you can only be restricted by one event, will have to change this later.
                if holder.msgs.get("held_msg"):
                    if print_txt:
                        print(holder.msgs["held_msg"])
                    return holder.msgs["held_msg"]
            else:
                if event.state == 1:
                    if event.msgs.get("held_msg"):
                        if print_txt:
                            print(event.msgs["held_msg"])
                        return event.msgs["held_msg"]

    def play_event_msg(self, msg_type="held", event=None, print_txt=True, noun=None):
        logging_fn()

        def print_current(event, state_type="held", print_text=False, noun:itemInstance=noun):
            logging_fn()
            if not event.msgs:
                print(f"NO EVENT MESSAGES FOR EVENT: {event}")
                return
            if event.msgs.get(f"{state_type}_msg"):
                msg = event.msgs[f"{state_type}_msg"]
                if "<material_msg>" in msg:
                    if not noun:
                        print(f"Require noun for end_msg, but no noun  provided for event {event}")
                    else:
                        material_type = noun.material_type
                        from itemRegistry import material_msgs
                        msg = msg.replace("<material_msg>", material_msgs.get(material_type))

                msg = events.clean_messages(event, noun, msg)
                if print_text:
                    print(f"{assign_colour(msg, colour='event_msg', noun=noun)}")
                return msg

            return f"Nothing to print print for event `{event}`, msg_type `{msg_type}`." # remove this later and replace with a type-defined default.

        if "_msg" in msg_type:
            msg_type = msg_type.replace("_msg", "")

        if msg_type == "exception":
            return print_current(event, state_type=msg_type, print_text=print_txt, noun=noun)

        if msg_type == "held":
            if self.travel_is_limited:
                if event == None:
                    event = self.held_at.get("held_by")

                return print_current(event, state_type=msg_type, print_text=print_txt, noun=noun)

        if not event:
            print("Need to define event for start/end messages.")
            return ""

        end_type = event.end_type
        if msg_type in ("start", "end"):
            if msg_type == "end":
                if end_type and end_type == "failure":
                    msg_type = "failure"

        return print_current(event, state_type=msg_type, print_text=print_txt, noun=noun)

    def do_immediate_actions(self, event:eventInstance, trig:Trigger|
                             timedTrigger, noun:itemInstance=None):

        inst = children = None
        if hasattr(event, "init_items") and event.init_items:
            for each in event.init_items:
                for k, outcome_name in event.init_items[each].items():
                    if k == "item_name":
                        entry = None
                        inst = None
                        item_name = None
                        if outcome_name in acts and noun:
                            target_itemname = None
                            print(f"Outcome name: {outcome_name}")
                            if hasattr(noun, "on_break") and "broken" in outcome_name:
                                target_itemname = noun.on_break
                            if hasattr(noun, "on_burned") and "burned" in outcome_name:
                                target_itemname = noun.on_burned
                                #print(f"Target_itemname: {target_itemname}")
                            if not target_itemname:
                                print(f"No target_itemname for {noun}.")

                                if "burned" in outcome_name and has_and_true(noun, "can_burn"):
                                    print("Burned in outcome name and item can burn.")
                                    print(f"Is it already burned: (hasattr) {hasattr(noun, "is_burned")}?")
                                    if hasattr(noun, "is_burned"):
                                        target_itemname = f"burned [[item_name]]"
                                else:
                                    target_itemname = "detritus"

                            item_name = target_itemname
                            print(f"Item name after target_itemname: {item_name}")

                            if "[[item_name]]" in item_name:
                                print("generating alt_state_item")
                                from itemRegistry import registry
                                item_name = item_name.replace("[[item_name]]", noun.name)
                                entry = registry.generate_alt_state_item(item_name, noun, state_change = outcome_name)
                                print(f"Entry after [[item_name]]: {entry}")

                        from itemRegistry import registry
                        if not item_name:
                            item_name = outcome_name
                        if not entry:
                            entry = registry.item_defs.get(item_name)
                            if not entry:
                                entry = registry.by_alt_names.get(item_name)
                                if not entry:
                                    from item_dict_gen import generator
                                    generator_alt_name = generator.alt_names.get(item_name)
                                    if generator_alt_name:
                                        item_name = generator_alt_name
                                        if registry.item_defs.get(item_name):
                                            entry = registry.item_defs.get(item_name)

                        if not entry:
                            print(f"No item def to use as a basis for {outcome_name}/{item_name}. Exiting. K: {k}, outcome_name: {outcome_name}")
                            exit()

                        entry = self.clean_altered_state_def(item_name, entry, outcome_name)
                        registry.item_defs[item_name] = entry
                        plural_words_dict = registry.plural_words
                        if len(item_name.split()) > 1:
                            plural_words_dict[item_name] = tuple(item_name.split())
                        inst = registry.init_single(item_name, entry)
                        if not inst:
                            print(f"Failed to generate instance for {item_name}. Exiting.")
                            from logger import traceback_fn
                            traceback_fn()
                            exit()

                        if hasattr(inst, "on_burn") and inst.on_burn == "ash pile": # for papers etc that can be burned twice. Need to define this clearly somewhere but this'll work for now.
                            inst.is_burned = False

                        event.items.add(inst)
                        inst.event = event
                        inst.is_event_key = False
                        from env_data import locRegistry
                        inst.location = locRegistry.current
                        registry.by_location[locRegistry.current].add(inst)
                        if event.effects_on_start:
                            for effect, item in event.effects_on_start.items():
                                if effect_attrs[effect].get("on_event_start"):
                                    for attr in effect_attrs[effect]["on_event_start"]:
                                        setattr(item, attr, effect_attrs[effect]["on_event_start"][attr])
                                        #print(f"EFFECT: {effect}, item: {item}")
                        registry.init_descriptions(inst = inst)
                        init_loc_descriptions(locRegistry.current)

                    else:
                        print(f"No item definition for {item_name}, cannot generate item for event {event}.")
                        return None

        if event.remove_items:
            #print(f"event.remove_items: {event.remove_items}")
            for each in event.remove_items:
                for item in event.remove_items[each]:
                    item = event.remove_items[each][item]
                    if isinstance(item, str) and item == "trigger_item":
                        items = set()
                        for item in event.event_keys:
                            items.add(item)
                        #print(f"ITEMS: {items}\nEVENT: {event}")
                        for item in items:
                            inst = item
                            if isinstance(inst, itemInstance):
                                #print("end hasattr children")
                                if hasattr(inst, "children") and inst.children:
                                    children = set()
                                    for child in inst.children:
                                        children.add(child)
                                    if children:
                                        for child in children:
                                            registry.move_item(child, inst.location, old_container=inst, no_print=True)
                                if inst in event.items:
                                    event.items.remove(inst)
                                if inst in event.event_keys:
                                    event.event_keys.remove(inst)
                                registry.delete_instance(inst)
                                inst = noun
                            else: print(f"Cannot remove {item} from event items, not present.")

        if inst:
            event.state = 1
            self.play_event_msg("start_msg", event, noun=inst)
            print()
            event.state = 0
            for trig in event.triggers:
                trig.state = 0
            return "Done", children


    def start_event(self, event_name:str, event:eventInstance=None, noun=None):
        logging_fn()

        if not event:
            to_be_current = self.event_by_name(event_name) # assumes all events already init, does not support dynamic event generation.
            #TODO: change event_by_name only supporting one instance per name.
        else:
            to_be_current = event

        event_state = to_be_current.state

        if event_state == 0:
            print(f"Event {event_name} is already over.")
            return

        if event_state == 1:
            print(f"Event {event_name} is already happening.")
            return

        if to_be_current.generate_on_start:
            from itemRegistry import registry
            for item in to_be_current.generate_on_start: # will only generate one per item_name (as it's a set), but I think this is preferred. Will need to add a way for an object to have multiple instances of item_name, though. TODO: this.
                inst = None
                if registry.item_defs.get(item):
                    inst = registry.init_single(item, registry.item_defs.get(item))
                    to_be_current.items.add(inst)
                    inst.event = to_be_current
                    from env_data import locRegistry
                    inst.location = locRegistry.current
                    if not inst:
                        print(f"Failed to generate instance for {item}")

        if to_be_current.effects_on_start:
            for effect, item in to_be_current.effects_on_start.items():
                print(f"EFFECT: {effect}, item: {item}") # untested, leaving the print here to remind myself to make sure it works.
                if effect_attrs[effect].get("on_event_start"):
                    for attr in effect_attrs[effect]["on_event_start"]:
                        setattr(item, attr, effect_attrs[effect]["on_event_start"][attr])

        for trigger in to_be_current.triggers:
            trigger.state = 1
            #print(f"Trigger: {trigger}, trig state: {trigger.state}")

        self.by_state.get(2).remove(to_be_current)
        self.by_state[1].add(to_be_current)

        to_be_current.state = 1

        if to_be_current in self.by_state.get(1): # redundant but just in case anything went super wrong:
            self.play_event_msg("start_msg", to_be_current, noun=noun)

        else:
            print(f"Cannot set event {event_name} as current event, because it is not present in future_events: {self.future_events}")
            exit()

        if hasattr(to_be_current, "effects"):
            if to_be_current.effects.get("limit_travel"):
                print(f"Started event limits travel: {to_be_current.effects["limit_travel"]}")# {"cannot_leave": "graveyard"}}
                if getattr(to_be_current, "msgs"):
                    self.play_event_msg("start_msg", to_be_current, noun=noun)


    def end_event(self, event_name, trigger:Trigger=None, noun=None):
        logging_fn()
        print_desc_again = False # Use to reprint the local description if items have become unhidden. Do it in a better way later, for now this will do.
        if isinstance(event_name, str):
            event_to_end = self.event_by_name(event_name)
        else:
            event_to_end = event_name

        if event_to_end in self.event_by_state(1):
            self.by_state[1].remove(event_to_end)
            self.by_state[0].add(event_to_end)
            if event_to_end in self.by_state[0]: # redundant but just in case anything went super wrong:
                event_to_end.state = 0

            if event_to_end.limits_travel:
                no_limits = True
                for event in self.by_state:
                    still_limited_to = set()
                    if event != event_to_end and hasattr(event, "limits_travel"):
                        for loc in event.travel_limited_to:
                            still_limited_to.add(loc)
                        no_limits = False

                if no_limits:
                    self.travel_is_limited = False
                    self.travel_limited_to = set()
                else:
                    self.travel_limited_to = still_limited_to

# The following all assume that all events only act on unique items (eg an item won't be hidden by multiple events (or if they are, cannot be revealed by any old one of them. Going with it to keep it simple for now.))
    ##NOTE: Absolutely this can be done using the new category entry in effect_attrs instead of going through it manually each time. Implement that.
            """
            if effect_attrs[effect].get("on_event_start"):
            #print(f"effect_attrs[effect]['on_event_start']: {effect_attrs[effect]['on_event_start']}")
            for k, v in effect_attrs[effect]["on_event_start"].items():
                setattr(event_item, k, v)
            """
            #print(f"event to end: hidden items:: {event_to_end.hidden_items}")
            from itemRegistry import registry
            for item_set in ("hidden_items", "held_items", "locked_items"):
                if getattr(event_to_end, item_set):
                    pop_me = set()
                    for item in getattr(event_to_end, item_set):
                        if effect_attrs.get(item_set) and effect_attrs[item_set].get("on_event_end"):
                            for k, v in effect_attrs[item_set]["on_event_end"].items():
                                setattr(item, k, v)

                        pop_me.add(item)
                        if item_set == "hidden_items": # NOTE: use this to make it print the description again after an end, so if something was meant to suddenly appear, use this (even if it wasn't technically hiding)
                            print_desc_again = True

                    if pop_me:
                        for item in pop_me:
                            if item not in getattr(event_to_end, item_set):
                                print(f"Cannot remove {item} from {event_to_end.name}.{item_set} as it's not there.")
                            else:
                                getattr(event_to_end, item_set).remove(item)
                                if hasattr(item, "is_event_key"):
                                    item.is_event_key = False # assuming each event key is only used once, which is true for now. Later may need alternate setups.

            for item in event_to_end.items:
                registry.init_descriptions(inst = item)
                if hasattr(item, "is_event_key"):
                    item.is_event_key = False

            if hasattr(event_to_end, "end_type") and event_to_end.end_type == "failure":
                self.play_event_msg(msg_type="failure", event=event_to_end, print_txt=True, noun=noun)

            else:
                print("")
                self.play_event_msg(msg_type="end", event=event_to_end, print_txt=True, noun=noun)

            if trigger:
                trigger.state = 0
            if print_desc_again:
                from env_data import get_loc_descriptions
                get_loc_descriptions(event_to_end.end_trigger_location)
                print(f"\nYou're facing {assign_colour(event_to_end.end_trigger_location.name)}. {event_to_end.end_trigger_location.description}")

            if hasattr(event_to_end, "end_type") and event_to_end.end_type == "failure" and hasattr(event_to_end, "remove_event_on_failure") and event_to_end.remove_event_on_failure:
        ## Genuinely not sure how useful or needed this is. If I just remove the event from events.events and remove the flag from the items, would that be enough? Idk. Will loko it up later. for now, this.

                triggers_to_remove = set()
                if event_to_end.triggers:
                    for trigger in event_to_end.triggers:
                        triggers_to_remove.add(trigger)
                    if triggers_to_remove:
                        for trigger in triggers_to_remove:
                            event_to_end.triggers.remove(trigger)
                if event_to_end.items:
                    remove_items = set()
                    for item in event_to_end.items:
                        remove_items.add(item)
                    for item in remove_items:
                        event_to_end.items.remove(item)
                        item.event = None
                events.events.remove(event_to_end)
                print(f"Event ended for noun {noun}")
        else:
            print(f"Cannot set event {event_name} as ended event, because it is not present in current_events: {self.event_by_state(1)} (type: { type(self.event_by_state(1))})")
            exit()

    def check_movement_limits(self)-> dict:

        allowed_locations_by_loc = {}
        for event in self.by_state[1]:
            if hasattr(event, "travel_limited_to"):
                for loc in event.travel_limited_to:
                    allowed_locations_by_loc.setdefault(loc, set()).add(event)

        return allowed_locations_by_loc

    def check_reason_tuple(self, reason, event, trig, noun_inst=None):
        #print(f"REASON TUPLE: {reason}, len: {len(reason)}") # will it always need to go to inner? Not sure.
        k, v = reason
        for condition in trig.triggers:
            if trigger_acts.get(condition) and trigger_acts[condition].get(k) == v:
                #print(f"EVENT VARS: {vars(event)}")
                if hasattr(event, "immediate_action_is_item") and event.immediate_action_is_item:
                    #print(f"[Is an immediate action event: {event}]")
                    done, moved_children = self.do_immediate_actions(event, trig, noun=noun_inst)
                    if done:
                        return 1, moved_children

                elif hasattr(event, "start_trigger_is_attr") and event.start_trigger_is_attr:
                    #print("START TRIG IS ATTR TRUE")
                    done, moved_children = self.do_immediate_actions(event, trig, noun=noun_inst)
                    if done:
                        return 1, moved_children
                #print(f"Condition [{k}: {v}] met for {noun_inst}. Will start event now.")
                self.start_event(event_name = event.name, event = event, noun=noun_inst)
                return 1, None

    def is_event_trigger(self, noun_inst, reason = None) -> (int|None):
        logging_fn()
        #print(f"Start of is_event_trigger. Noun details: {vars(noun_inst)}")
        def check_triggers(event:eventInstance, noun:itemInstance, reason) -> (int|None)|list:
            logging_fn()
            moved_children = None
            if event.end_triggers:
                for trig in event.end_triggers:
                    if hasattr(trig, "persistent_condition"):
                        #print("Trigger is a persistent_condition")
                        if reason and isinstance(reason, tuple): # new rule: persistent conditions should always send reason as a tuple.
                            duration, time_unit = reason
                            if time_unit != trig.time_unit:
                                print(f"Incoming time_unit (`{time_unit}`) doesn't match the trigger's expectation: `{trig.time_unit}`")
                                exit()
                            if duration >= trig.full_duration:
                                print("Duration met, end trigger.")
                                self.end_event(event, trig, noun=noun_inst)
                                return 1, None
                        # This should only trigger by time
                        continue

                    if trig.is_item_trigger and trig.item_inst == noun:
                        if isinstance(reason, str):
                            if reason in trig.triggers:
                               # print(f"reason in trig.triggers: {reason} /// {trig.triggers}")
                                #if not trig.start_trigger:
                                    #print(f"This trigger [{trig}] is not a start trigger.")
                                if reason in requires_end_trigger_loc:
                                    if hasattr(trig, "item_inst_loc") and getattr(trig, "item_inst_loc") != None and trig.item_inst_loc != noun.location:
                                        continue

                                if hasattr(trig, "exceptions") and trig.exceptions:
                                    for exception in trig.exceptions:
                                        print(f"Exception: {exception}")
                                        if exception == "current_loc_is_inside":
                                            from env_data import locRegistry
                                            #print(f"locRegistry.current.place: {locRegistry.current.place}")
                                            #print(f"inside: {locRegistry.current.place.inside}")
                                            if locRegistry.current.place.inside:
                                                self.play_event_msg( msg_type="exception", event=event, print_txt=True, noun=noun)
                                                return 1, None

                                self.end_event(event, trig, noun)
                                return 1, None

                        elif isinstance(reason, tuple):
                            #print(f"REASON TUPLE: {reason}, len: {len(reason)}") # will it always need to go to inner? Not sure.
                            if len(reason) == 1:
                                reason = reason[0]
                            #for inner in reason:
                            k, v = reason
                            for condition in trig.triggers:
                                #print(f"condition in triggers: {condition}")
                                if trigger_acts.get(condition) and trigger_acts[condition].get(k) == v:
                                    #print(f"Condition [{k}: {v}] met for {noun_inst}. Will end event now.")
                                    self.end_event(event, trig, noun=noun_inst)
                                    return 1, None
                        else:
                            print(f"Could not parse {reason}, type: {type(reason)}")
                    else:
                        if trig.is_item_trigger:
                            print(f"item inst {trig.item_inst} =! noun {noun}")
                    #print("After if trig.is_item_trigger and trig.item_inst == noun:")
                    return 0, None # No sucessful end triggers

            elif event.start_triggers:
                for trig in event.start_triggers:
                    print(f"start trigger: {vars(trig)}")
                    if trig.is_item_trigger and trig.item_inst == noun:
                        print(f"trig.is_item_trigger: {trig.is_item_trigger}")
                        if isinstance(reason, str):
                            if reason in trig.triggers:
                                reason = tuple((reason))
                                print(f"Reason is in trig.triggers: {reason} // trig.triggers: {trig.triggers}")
                        if isinstance(reason, tuple):
                            print("checking reason tuple")
                            outcome, moved_children = self.check_reason_tuple(reason, event, trig, noun_inst)
                            if outcome:
                                return outcome, moved_children
                print("end of event.start_triggers")

        if noun_inst.event:
            if noun_inst.event and hasattr(noun_inst, "is_event_key") and noun_inst.is_event_key:
                print(f"Noun {noun_inst} is an event trigger for {noun_inst.event}")
                outcome, moved_children = check_triggers(noun_inst.event, noun=noun_inst, reason=reason)
                return outcome, moved_children
            #else:
                #print(f"Noun is not event key. noun vars:\n{vars(noun_inst)}\n\n")

        if events.generate_events_from_itemname.get(noun_inst.name):
            event_name = events.generate_events_from_itemname[noun_inst.name]

            if hasattr(noun_inst, "event") and noun_inst.event:
                print(f"Existing noun event: {noun_inst}")
                print(f"noun_inst.event: {noun_inst.event}")
                if noun_inst.event.name == event_name:
                    print(f"Noun {noun_inst} already has a running event by this name. Not starting another new one.")
                    exit()
            intake_event = registrar.by_name.get(event_name)

            if intake_event and hasattr(intake_event, "start_trigger") and intake_event.start_trigger.get("item_trigger"):
                if intake_event.start_trigger["item_trigger"].get("match_item_by_name_only"):
                    print(f"generate events from itemname: {noun_inst.name} / {event_name}\nReason item is in this check? {reason}")
                    #print(f"INTAKE EVENT: \n{vars(intake_event)}")
                    if intake_event.start_trigger["item_trigger"].get("triggered_by"):
                        print(f"intake_event.triggered_by: {intake_event.start_trigger["item_trigger"].get("triggered_by"):}")
                        if isinstance(reason, str):
                            if reason in intake_event.start_trigger["item_trigger"].get("triggered_by"):
                                event = register_generated_event(event_name, noun_inst, reason_str = reason)
                                self.start_event(event_name = event.name, event = event, noun=noun_inst)
                                print(f"STARTED EVENT: {event}, ITEM: {noun_inst}")
                                return "success", None # I don't think this will ever have moved_children? If it does I'll need to change things.

            if event.no_item_restriction[noun_inst.name] == noun_inst:
                print(f"Item is part of an existing event: {event}")
                print("Do anything involving item triggers here (eg if dropping it fails the event, that will happen here.)")
                check_triggers(event, noun=noun_inst, reason=reason)
                return reason, moved_children

        if isinstance(reason, tuple):
            #for inner in reason:
            reason_str, _ = reason
            if reason_str in acts:
                print("reason str in acts")
                if hasattr(noun_inst, reason_str) and getattr(noun_inst, reason_str):
                    print(f"Item already {reason_str}, continuing.")
                    return None, None
                setattr(noun_inst, reason_str, True)
                event_name = self.get_event_name_by_attr_trigger(reason)
                if not event_name:
                    print(f"No event found with this attr trigger reason: {reason}. Cannot generate event. (Not a problem if it wasn't expected. Tailor this later.)")
                    return None, None
                event = register_generated_event(event_name, noun_inst, reason_str)
                outcome, moved_children = check_triggers(event, noun=noun_inst, reason=reason) # Should this not be reason=reason_str? I just do the loop again here... #TODO
                return outcome, moved_children
            else:
                return None, None

        elif isinstance(reason, str):
            event_name = self.get_event_name_by_attr_trigger(reason)
            if not event_name:
                #print(f"No event found with this attr trigger reason: {reason}. Not unexpected, no current enents would trigger this. Delete msg later.)")
                return None, None
            event = register_generated_event(event_name, noun_inst, reason_str)
            outcome, moved_children = check_triggers(event, noun=noun_inst, reason=reason)

        return outcome, moved_children


events = eventRegistry()

class eventIntake:

    def setup_timed_events(self, attr):
        logging_fn()
        self.time_unit = attr["end_trigger"]["timed_trigger"]["time_unit"]
        self.full_duration = attr["end_trigger"]["timed_trigger"]["full_duration"]
        self.persistent_condition = attr["end_trigger"]["timed_trigger"]["persistent_condition"]

    def __init__(self, event_name, attr):

        self.name = event_name
        self.start_trigger_is_item = False
        self.start_trigger_is_attr = False
        self.attr_triggers = set()
        self.end_trigger_is_item = False
        self.item_names = set()
        self.item_name_to_loc = {}
        self.hidden_items = set()
        self.held_items = set()
        self.locked_items = set()

        self.print_description_plain = set()

        self.is_generated_event = attr.get("is_generated_event")
        if self.is_generated_event:
            self.starts_current = False
        else:
            self.starts_current = attr.get("starts_current")

        self.is_timed_event = attr.get("is_timed_event")
        self.remove_event_on_failure = attr.get("remove_event_on_failure")

        self.start_trigger = attr.get("start_trigger")
        self.end_trigger = attr.get("end_trigger")

        for trigger_type in ("start_trigger", "end_trigger", "immediate_action"):
            if attr.get(trigger_type):
                for trig, val in attr[trigger_type].items():
                    if trig == "item_trigger":
                        setattr(self, f"{trig}_is_item", True)
                        if trigger_type == "immediate_action":
                            if not self.start_trigger:
                                self.start_trigger = (attr.get("immediate_action"))
                        setattr(self, f"start_trigger_is_item", True)

                        self.item_names.add(val.get("trigger_item"))
                        if val.get("trigger_location"):
                            self.item_name_to_loc[val["trigger_item"]] = val["trigger_location"]
                        if val.get("print_description_plain"):
                            for item in val["triggered_by"]:
                                self.print_description_plain.add(item)
                    elif trig == "attribute_trigger":
                        self.start_trigger_is_attr = True
                        if trigger_type == "immediate_action":
                            if not self.start_trigger:
                                self.start_trigger = (attr.get("immediate_action"))
                        if val.get("triggered_by"):
                            for item in val["triggered_by"]:
                                self.attr_triggers.add(item)

        if self.end_trigger:
            if attr["end_trigger"].get("item_trigger"):
                self.end_type = (attr["end_trigger"]["item_trigger"].get("end_type") if attr["end_trigger"]["item_trigger"].get("end_type") != None else "success")
        else:
            self.end_type = None
        if attr.get("effects"):
            for effect in attr.get("effects"):
                if effect_attrs.get(effect):
                    for entry in attr["effects"][effect]:
                        self.item_names.add(attr["effects"][effect][entry].get("item_name"))
                        self.item_name_to_loc[attr["effects"][effect][entry].get("item_name")] = attr["effects"][effect][entry].get("item_location")
                        getattr(self, effect).add(attr["effects"][effect][entry].get("item_name"))
                else:
                    setattr(self, effect, attr["effects"][effect])
                    if effect == "limit_travel":
                        self.limit_travel = True
                        if attr["effects"]["limit_travel"].get("cannot_leave"):
                            self.travel_limited_to = attr["effects"]["limit_travel"]["cannot_leave"]

        if self.is_generated_event:
            if self.start_trigger_is_item:
                self.match_item_to_name_only = attr["start_trigger"]["item_trigger"].get("match_item_by_name_only")

            self.repeats = attr.get("repeats")

        if self.is_timed_event:
            self.setup_timed_events(attr)

        self.messages = attr.get("messages")
        """
        Basically I think this should be the base 'structure' of each event. No item instances, no triggerInst, no locInst, just the raw data but processed to be exactly what eventRegistry expects for init.
        Hell, maybe we use this for /all/ events during setup, but only stick around for the generated ones. Can just delete the old ones if we really care that much.
        """
    def __repr__(self):
        return f"<eventIntake {self.name} (start_trigger: {self.start_trigger}), (end_trigger: {self.end_trigger})>"


def add_items_to_events(event = None, noun_inst = None):
    logging_fn()

    def assign_event_keys(event):

        for item in event.items:
            if hasattr(item, "requires_key"):
                if hasattr(item, "key_is_placed_elsewhere"):
                    if isinstance(item.key_is_placed_elsewhere, dict):
                        if item.key_is_placed_elsewhere.get("item_in_event"):
                            event_with_key = item.key_is_placed_elsewhere["item_in_event"]
                            key_event = events.event_by_name(event_with_key)

                            key_item_names = {}

                            for potential_key in key_event.items:
                                if isinstance(potential_key, itemInstance):
                                    key_item_names[potential_key.name] = potential_key

                            if key_item_names.get(item.requires_key):
                                item.requires_key = key_item_names[item.requires_key]
                        else:
                            print("Later, can add item locations to the event dict and find them through this. For now it only does event-held keys though.")
                else:
                    if events.item_names.get(item.requires_key):
                        item.requires_key = events.item_names[events.item_names[item.requires_key]]

    if noun_inst:
        noun = noun_inst
    else:
        noun = None

    if event:
        if isinstance(event, str):
            event_name = event
            event = None
        else:
            event_name = event.name

        events.get_event_triggers(event, event_name, trigger_check = noun)

        events.get_event_item_names(event)

        assign_event_keys(event)

    else:
        for event in events.events:
            events.get_event_triggers(event) # each loop done separately so event_item_names gets the complete dataset from the previous.

        for event in events.events:
            events.get_event_item_names(event)

        for event in events.events:
            assign_event_keys(event)



class eventRegistrar:

    def __init__(self):

        self.events = set()
        self.by_name = dict()
        self.generate_events_from_itemname = dict()
        self.start_trigger_is_item = dict()
        self.start_trigger_is_attr = dict()

        """
        Every time_unit, we check if persistent_condition is still met, and if so, amend the constraint tracking. In addition, if the criteria for persistent_contition to end are met, we check (eg if item "moss" is removed from inventory).

        time information will be in end_trigger, because that's the only thing that makes sense. It ends if the timer completes, so we put it there. Start trigger doesn't need to know how long it has to run for.
        """

    def add_to_intake(self, event_name, attr):

        event = eventIntake(event_name, attr)

        self.events.add(event)

        if event.is_generated_event:
            if event.start_trigger_is_item:
                events.generate_events_from_itemname[event.start_trigger["item_trigger"]["trigger_item"]] = event.name


        if event.start_trigger_is_item:
            if event.start_trigger:
                self.start_trigger_is_item[event] = event.start_trigger["item_trigger"]["trigger_item"]

        if event.start_trigger_is_attr:
            if event.start_trigger:
                self.start_trigger_is_attr[event] = event.attr_triggers

        self.by_name[event.name] = event

        return event, attr

registrar = eventRegistrar()

def register_generated_event(event_name, noun, reason_str):
    if not event_dict.get(event_name):
        print(f"Cannot generate event `{event_name}` as {event_name} is not in the event defs file.")
        exit()

    intake_event, _ = registrar.add_to_intake(event_name, event_dict[event_name])
    event_inst, event_entry = events.add_event(intake_event.name, vars(intake_event))

    events.get_all_item_instances(event_inst, event_entry, noun)
    add_items_to_events(event_inst, noun)
    return event_inst


def initialise_eventRegistry():

    print("Initialising event registry...")
    for event_name in event_dict:
        registrar.add_to_intake(event_name, event_dict[event_name])
    """
    So at this point - it has the item  names for all triggers/effects, but no instances.
    """

    for event in registrar.events:
        if not getattr(event, "is_generated_event"):
            event_inst, event_entry = events.add_event(event.name, vars(event))
            events.get_all_item_instances(event_inst, event_entry)


if __name__ == "__main__":

    run_full = True

    if run_full == True:
        from env_data import initialise_placeRegistry
        initialise_placeRegistry()
        from itemRegistry import initialise_itemRegistry
        initialise_itemRegistry()
        initialise_eventRegistry()
        if events.travel_is_limited:
            print(events.check_movement_limits())
